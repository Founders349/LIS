#!/usr/bin/env python
import random
import json
import logging
import sys
import cmd as cmd
# Stores information in the log
logging.basicConfig(filename = 'Rooms.log', level=logging.DEBUG)

playerList = []
availableCharacters = ["Engineer", "Doctor", "Veteran", "Technician", "Chemist", "Astronaut", "Delegate"]
# Rolls a die based on a given number of sides
def roll(Nsides):
    roll=random.randint(1, Nsides)
    return(roll)
                                            ### Start Map Generation ###
# gets the map size based of user input
def get_map_size():
    num_of_tiles = 0
    while num_of_tiles == 0:
        mapsize = input('Enter S/M/L: ')
        if mapsize.upper() == 'S':
            num_of_tiles = random.randrange(25, 35)
            print("The Map is", num_of_tiles, "Tiles")
            return num_of_tiles
        elif mapsize.upper() == 'M':
            num_of_tiles = random.randrange(40, 60)
            print("The Map is", num_of_tiles, "Tiles")
            return num_of_tiles
        elif mapsize.upper() == 'L':
            num_of_tiles = random.randrange(80, 100)
            print("The Map is", num_of_tiles, "Tiles")
            return num_of_tiles

# stores the map size so we can make the map
num_of_tiles = get_map_size()
# Creates the map size returning the amount of rows and columns
def map_step_one():
    if num_of_tiles < 36:
        rows, cols = (7,7)
        return rows, cols
    elif 36 < num_of_tiles < 61:
        rows, cols = (9,9)
        return rows, cols
    else:
        rows, cols = (11,11)
        return rows, cols
# Stores map template
rows, cols = map_step_one()

# creates map as a list
def map_step_two():
    map = [[0 for x in range(rows)] for x in range(cols)]
    return map
# stores the map
map = map_step_two()
# prints the map in a useable way
def print_map():
    for i in range(len(map)):
        for j in range(len(map[i])):
            print(map[i][j], end=" ")
        print()

# creates blank tiles
def map_step_three():
    if num_of_tiles < 36:
        num_of_blanks = 49 - num_of_tiles
        return num_of_blanks
    elif 36 < num_of_tiles < 61:
        num_of_blanks = 81 - num_of_tiles
        return num_of_blanks
    else:
        num_of_blanks = 121 - num_of_tiles
        return num_of_blanks

# stores blank tiles
num_of_blanks = map_step_three()

# Function to check if the room can take more of that room type (Doesnt do anything but im afraid to take it out)
def check_avail(x):
    if map.count(x) < 10: return True
    else: return False

# Replaces blank rooms with random room types
def map_step_four(num_of_blanks, num_of_tiles):
    i, j = (0, 0)
    blanks = num_of_blanks
    tiles = num_of_tiles
    while ((blanks + tiles - 1) > 0):
        room = random.randrange(0,7)
        if room == 0 and (blanks > 0):
            map[i][j] = room
            blanks -= 1
            if j < rows-1:
                j += 1
            else:
                j = 0
                i += 1
        elif check_avail(room) == True:
            tiles -= 1
            if j < rows-1:
                j += 1
                map[i][j] = room
            else:
                i, j = (i+1, 0)
                map[i][j] = room

# Start up function that makes the map
def make_map():
    map_step_one()
    map_step_two()
    map_step_three()
    map_step_four(num_of_blanks, num_of_tiles)
    print_map()
                                               ### Start Loot Generation ###
# generates random numbers that gather loot for the rooms based on the max amount of loot
# grabs a random piece of loot from the json dictionary
def randomLootGenerator(randomLootList):
  return randomLootList[random.randrange(len(randomLootList))]

# makes a dictionary for the rooms
# Variables to aid with filling rooms and storing blanks
roomDict = {}
roomList = []
roomDictBlank = {}

# Function that records the position of all of the blank spaces to make parsing through the room list easier
def assign_blank(i,j):
    roomPosBlank = []
    roomPosBlank.append(i)
    roomPosBlank.append(j)
    roomDictBlank["position"] = roomPosBlank
    roomDict_copyBlank = roomDictBlank.copy()
    roomList.append(roomDict_copyBlank)
    return roomList
# Function uses a room number and the coords on the map to randomly generate a dictionary for that room which includes
# position, type, and random loot. It then logs the rooms.
def assign_loot(roomNum, i, j):
    roomfiles = ["./Room1.json", "./Room2.json", "./Room3.json", "./Room4.json", "./Room5.json", "./Room6.json"]
    with open(roomfiles[roomNum-1]) as f:
        roomjson = json.load(f)
    assert isinstance(roomjson, dict)
    roomPos = []
    roomPos.append(i)
    roomPos.append(j)
    roomDict["position"] = roomPos
    roomDict["Type"] = (roomjson.get("Type"))
    lootList = []
    for m in range(roomjson.get("MaxLoot")):
        loot = randomLootGenerator(roomjson.get("Loot"))
        lootList.append(loot)
    roomDict["Loot"] = lootList
    #logging.info(roomDict)
    roomDict_copy = roomDict.copy()
    roomList.append(roomDict_copy)
    return roomList
# This function randomly assigns cover which will be used for attacking and defending. This could probably go in assign
# loot but I perfer to have to functions in case I want to remove this feature.
def assign_cover(roomNum,i,j):
    roomfiles = ["./Room1.json", "./Room2.json", "./Room3.json", "./Room4.json", "./Room5.json", "./Room6.json"]
    with open(roomfiles[roomNum-1]) as f:
        roomjson = json.load(f)
    assert isinstance(roomjson, dict)
    listI = i * 10
    if i == 0:
        listJ = j
    else:
        listJ = j + i
    listNum = listI + listJ
    coverList = []
    for m in range(roomjson.get("MaxCover")):
        cover = randomLootGenerator(roomjson.get("Cover"))
        coverList.append(cover)
    roomList[listNum]["Cover"] = coverList
    return roomList
def final_cover_assign():
    for i in range(rows):
        for j in range(cols):
            if map[i][j] == 0:
                pass
            elif map[i][j] == 1:
                roomNUM = 1
                assign_cover(roomNUM, i, j)
            elif map[i][j] == 2:
                roomNUM = 2
                assign_cover(roomNUM, i, j)
            elif map[i][j] == 3:
                roomNUM = 3
                assign_cover(roomNUM, i, j)
            elif map[i][j] == 4:
                roomNUM = 4
                assign_cover(roomNUM, i, j)
            elif map[i][j] == 5:
                roomNUM = 5
                assign_cover(roomNUM, i, j)
            elif map[i][j] == 6:
                roomNUM = 6
                assign_cover(roomNUM, i, j)
            else:
                pass


# prints roomList in a human-readable way
def print_Rooms():
    for i in range(len(roomList)):
        print(roomList[i], end = "\n")
# Runs through the map and assigns random loot based off of the room type calling assign_loot() to assign the loot
def final_loot_assign():
    for i in range(rows):
        for j in range(cols):
            if map[i][j] == 0:
                assign_blank(i,j)
            elif map[i][j] == 1:
                roomNUM = 1
                assign_loot(roomNUM, i, j)
            elif map[i][j] == 2:
                roomNUM = 2
                assign_loot(roomNUM, i, j)
            elif map[i][j] == 3:
                roomNUM = 3
                assign_loot(roomNUM, i, j)
            elif map[i][j] == 4:
                roomNUM = 4
                assign_loot(roomNUM, i, j)
            elif map[i][j] == 5:
                roomNUM = 5
                assign_loot(roomNUM, i, j)
            elif map[i][j] == 6:
                roomNUM = 6
                assign_loot(roomNUM, i, j)
            else:
                pass
# A function that prints the loot in a certain room
# Returns error when finding loot of "zero room" will be fixed when placement is fixed
# Requires more testing but works for most basic cases (check the ends tho)
def print_Loot(i,j):
    listI = i * 10
    if i == 0:
        listJ = j
    else:
        listJ = j + i
    listNum = listI + listJ
    #print(listNum)
    roomLoot = roomList[listNum]["Loot"]
    print(roomLoot)
    return

def print_Cover(i,j):
    listI = i * 10
    if i == 0:
        listJ = j
    else:
        listJ = j + i
    listNum = listI + listJ
    roomCover = roomList[listNum]["Cover"]
    print(roomCover)
    return
                                               ### Start PC's ###
# Creates the Character
    # Rolls stats
def roll(x):
    dOne = random.randint(1, 6)
    dTwo = random.randint(1, 6)
    dThree = random.randint(1, 6)
    dFour = random.randint(1, 6)
    dTotal = dOne + dTwo + dThree + dFour
    list1 = [dOne, dTwo, dThree, dFour]
    list1.sort()
    abilityScore= dTotal - min(list1)
    return abilityScore, list1
# Lets the player reroll some of their stats
def reroll(list2):
    whichRoll = input("Which roll? ")
    num = int(whichRoll) - 1
    list2[num][1].remove(min(list2[num][1]))
    list2[num][1].append(random.randint(1,6))
    list2[num][1].sort(),
    num_1= sum(list2[num][1]) - min(list2[num][1])
    list2[num] = (num_1, list2[num][1])
    return list2

# Lets the player choose what stats they want where
# Needs to let the user put nothing or text without breaking lol
def orient_stats(list2):
    list3 = []
    availRolls = [1,2,3,4]
    first = 0
    while first not in availRolls:
        first= int(input("Which roll should be STR? "))
    list3.append(list2[first-1][0])
    availRolls.pop(availRolls.index(first))
    second = 0
    while second not in availRolls:
        second = int(input("Which roll should be AC? "))
    list3.append(list2[second-1][0])
    availRolls.pop(availRolls.index(second))
    third = 0
    while third not in availRolls:
        third = int(input("Which roll should be WS? "))
    list3.append(list2[third-1][0])
    availRolls.pop(availRolls.index(third))
    fourth = 0
    while fourth not in availRolls:
        fourth = int(input("Which roll should be BS? "))
    list3.append(list2[fourth-1][0])
    return list3
# Converts a string to a class
def str_to_class(classname):
    return getattr(sys.modules[__name__], classname)
# creates the character
def character_create(type, player):
    roll(1), roll(2), roll(3), roll(4)
    list2 = [roll(1) ,roll(2),roll(3),roll(4)]
    print(list2)
    max_reroll = 3
    for i in range(max_reroll):
        ans = input("Would you like to reroll? ")
        if ans.lower() == "yes":
            reroll(list2)
            print(list2)
        elif ans.lower() == "no":
            break
    list3 = orient_stats(list2)
    STR = list3[0]
    AC = list3[1]
    WS = list3[2]
    BS = list3[3]
    type = str_to_class(type)
    player = type(STR,AC,WS,BS)
    return player
# This function makes all of the playable characters and then adds them to a list of players
def make_players():
    players = int(input("How many players? "))
    for i in range(players):
        playerNum = str(len(playerList)+1)
        print("Player " + playerNum + ", what would you like to be? " + str(availableCharacters))
        type = ""
        while type not in availableCharacters:
            type = input()
        availableCharacters.remove(type)
        playerList.append(character_create(type,playerNum))

# Function that puts the character in a random place on the map that is non-zero
def randomPos(name):
    if map[name.i][name.j] == 0:
        newI = random.randrange(rows)
        newJ = random.randrange(cols)
        name.i = newI
        name.j = newJ
    if map[name.i][name.j] == 0:
        randomPos(name)
    return
# defines Playable Characters
class Human:

    #initializes character with character stats
    def __init__(self, strength, AC, WS, BS):
        self.strength = strength
        self.AC = AC
        self.WS = WS
        self.BS = BS

# subclasses of Human
class Engineer(Human):
    health = 50
    isdead = False
    will_move = "N"
    will_interact = "N"
    will_attack = "N"
    will_loot = "N"
    will_cover = "N"
    inventory = []
    cover = ""
    win = False
    i = 0
    j = 0
    equiptment = "maintenance tool"
    skill = "Override"
    name = "Engineer"
class Doctor(Human):
    health = 50
    isdead = False
    will_move = "N"
    will_interact = "N"
    will_attack = "N"
    will_loot = "N"
    will_cover = "N"
    inventory = []
    cover = ""
    win = False
    i = 0
    j = 0
    equiptment = "Meds"
    equiptment_amount = 2
    skill = "PHD", "Blood Timer"
    name = "Doctor"
class Veteran(Human):
    health = 50
    isdead = False
    will_move = "N"
    will_interact = "N"
    will_attack = "N"
    will_loot = "N"
    will_cover = "N"
    inventory = []
    cover = ""
    win = False
    i = 0
    j = 0
    equiptment = "Deagle"
    skill = "Pilot"
class Technician(Human):
    health = 50
    isdead = False
    will_move = "N"
    will_interact = "N"
    will_attack = "N"
    will_loot = "N"
    will_cover = "N"
    inventory = []
    cover = ""
    win = False
    i = 0
    j = 0
    name = "Technician"
    pass
class Chemist(Human):
    health = 50
    isdead = False
    will_move = "N"
    will_interact = "N"
    will_attack = "N"
    will_loot = "N"
    will_cover = "N"
    inventory = []
    cover = ""
    win = False
    i = 0
    j = 0
    name = "Chemist"
    pass
class Astronaut(Human):
    health = 50
    isdead = False
    will_move = "N"
    will_interact = "N"
    will_attack = "N"
    will_loot = "N"
    will_cover = "N"
    inventory = []
    cover = ""
    win = False
    i = 0
    j = 0
    name = "Astonaut"
    pass
class Delegate(Human):
    health = 50
    isdead = False
    will_move = "N"
    will_interact = "N"
    will_attack = "N"
    will_loot = "N"
    will_cover = "N"
    inventory = []
    cover = ""
    win = False
    i = 0
    j = 0
    name = "Delegate"
    pass
# Reset the cover of a play
def reset_cover(name):
    name.cover = ""
    return name.cover
# basic attack setup
# checks for attack
def check_Attack(name):
    case = 0
    while case == 0:
        will_attack = input("Will you attack? Y/N ")
        if will_attack.lower() == "y":
            name.will_attack = "Y"
            break
        elif will_attack.lower() == "n":
            name.will_attack = "N"
            break
        else: name.will_attack = "N"
    return name.will_attack
# deals the damage (hopefully this will be able to encompass modifiers lol
def attack(name, damage):
    name.health = (name.health - damage)
    return name.health

                                           ### Start turn based functions ###
# Checks if the player is dead
def isDead(name):
    if name.health <=0:
        name.isdead = True
    else:
        name.isdead = False
# Asks the player if they want to interact with an object
def check_Interact(name):
    will_interact = input("Will you interact with the current room? Y/N ")
    if will_interact.lower() == "y":
        name.will_interact = "Y"
    elif will_interact.lower() == "n":
        name.will_interact = "N"
    else:
        name.will_interact = "N"
    return name.will_interact
# Moves the player shows the player where they can move needs a little more testing but it should work
def move(name):
    case = 0
    while case == 0:
        will_move = input("Will you move? Y/N ")
        if will_move.lower() == "y":
            name.will_move = "Y"
            break
        elif will_move.lower() == "n":
            name.will_move = "N"
            break
        else:
            name.will_move = "N"
    moveableSpaces = []
    u = name.i - 1
    d = name.i + 1
    r = name.j + 1
    l = name.j - 1
    try:
        if u <= 0:
            pass
        elif map[u][name.j] != 0:
            moveableSpaces.append("Up")
        if d >= rows - 1:
            pass
        elif map[d][name.j] != 0:
            moveableSpaces.append("Down")
        if r >= rows - 1:
            pass
        elif  map[name.i][r] != 0:
            moveableSpaces.append("Right")
        if l <= 0:
            pass
        elif map[name.i][l] != 0:
            moveableSpaces.append("Left")
    except:
        pass
    if (name.will_move == 'Y'):
        print("You can move", moveableSpaces)
        move = input("Which direction will you move? ")
        try:
            if move.lower() == "up" and map[name.i-1][name.j] !=0 and name.i >= 0:
                name.i -= 1
                reset_cover(name)
            elif move.lower() == "down" and map[name.i+1][name.j] != 0 and name.i <= rows -1:
                name.i += 1
                reset_cover(name)
            elif move.lower() == "left" and map[name.i][name.j-1] != 0 and name.j >= 1:
                name.j -= 1
                reset_cover(name)
            elif move.lower() == "right" and map[name.i][name.j+1] != 0 and name.j <= cols -1:
                name.j += 1
                reset_cover(name)
            else: pass
            describe_Room(name)
            loot(name)
        except:
            pass
# Unfinished function that lets the player extract loot from a room after asking them if they will loot the room
# Needs more testing but looks promising NEEDS TO LOOP AROUND -> This might happen in the Calling portion
def loot(name):
    case = 0
    while case == 0:
        check_loot = input("Will You Check For Loot? Y/N ")
        if check_loot.lower() == "y":
            i = name.i
            j = name.j
            name.will_loot = "Y"
            print_Loot(i, j)
            break
        elif check_loot.lower() == "n":
            name.will_loot = "N"
            return
        else:
            name.will_loot = "N"
            return
    i = name.i
    j = name.j
    listI = i * 10
    if i == 0:
        listJ = j
    else:
        listJ = j + i
    listNum = listI + listJ
    roomLoot = roomList[listNum]["Loot"]
    if len(roomLoot) == 0:
        return
    whichLoot = input("What will you take? ")
    while whichLoot.lower() not in roomLoot:
            if whichLoot.lower() == "nothing":
                name.will_loot = "N"
                break
            else:
                print(roomLoot)
                whichLoot = input("What will you take? ")
    if whichLoot.lower() == 'nothing':
        return name.inventory
    else:
        name.inventory.append(whichLoot)
        roomLoot.pop(roomLoot.index(whichLoot))
    return name.inventory
# This function asks the player if they would like to cover themselves and shows the player the cover that is available
# May still need work.
def cover(name):
    case = 0
    while case == 0:
        will_cover=input("Will you attempt to get behind cover? Y/N ")
        if will_cover.lower() == "y":
            i = name.i
            j = name.j
            print_Cover(i,j)
            break
        elif will_cover.lower() == "n":
            return name.will_cover == "N"
    i = name.i
    j = name.j
    listI = i * 10
    if i == 0:
        listJ = j
    else:
        listJ = j + i
    listNum = listI + listJ
    roomCover = roomList[listNum]["Cover"]
    if len(roomCover) == roomCover.count("No-Cover"):
        reset_cover(name)
        return
    elif roomCover.count("No-Cover") > 0:
        x = roomCover.count("No-Cover")
        for x in roomCover:
            y = roomCover.index("No-Cover")
            roomCover.pop(y)
    whichCover = input("Which Cover? ")
    while whichCover not in roomCover:
        if whichCover.lower() == "nothing":
            name.will_cover= "N"
            return name.will_cover
        else:
            print(roomCover)
            whichCover = input("Which Cover? ")
    name.cover = whichCover
    return name.cover
# This function describes the room to the player
# Figure out how to make people inhabit rooms for other players
def describe_Room(name):
    i_pos = name.i
    j_pos = name.j
    listI = i_pos * 10
    if i_pos == 0:
        listJ = j_pos
    else:
        listJ = j_pos + i_pos
    listNum = listI + listJ
    room = roomList[listNum]["Type"]
    print("You have entered a {}".format(room))
    otherPlayerListv1 = playerList.copy()
    otherPlayerListv2 = []
    for object in otherPlayerListv1:
        otherPlayerListv2.append(object.name)
    print(otherPlayerListv2)
    playersInRoom = []
    for player in otherPlayerListv2:
        if player.i and player.j == name.i and name.j:
            playersInRoom.append(player)
    case= 0
    while case == 0:
        ans = input("Would you like to look around the room? ")
        #improvement
        if ans.lower() == "yes":
            if len(playersInRoom) > 0:
                print("You see {} and the {}".format(roomList[listNum]["Cover"],playersInRoom))
            else:
                print("You see {}".format(roomList[listNum]["Cover"]))
            break
        elif ans.lower() == "no":
            break
    return



def checkWin(name):
    if len(name.inventory) >= 2:
        name.win = True
    return name.win
def run_Turn(name):
    print("{}, it is your turn.".format(name.name))
    describe_Room(name)
    loot(name)
    move(name)
    position(name)
    print(name.inventory)
# Checks the position of a player
def position(name):
    print(name.i, name.j)
# Start up function
def start_up():
    make_map()
    final_loot_assign()
    final_cover_assign()
    make_players()
    for player in playerList:
        randomPos(player)
#actually runs the game
def playGame():
    game = "unwon"
    while game == "unwon":
        for player in playerList:
            run_Turn(player)
            checkWin(player)
            if player.win == True:
                print("Winner")
                return

# tests all the code
def main():
    start_up()
    Engineer.i = 5
    Engineer.y = 5
    Doctor.i = 5
    Doctor.y = 5
    run_Turn(Doctor)

    #playGame()
    # For the initialization of characters, make max number of players a list then create players based off of that list
    # which will be player_list and have a function that assigns the characters based on what the player wants to that
    # list slot so it will be easier fr turns
    #print(num_of_tiles)
    #make_map() # I think this is printing the map
    #make_players()
    #randomPos(Engineer)
    #print(Engineer.i,Engineer.j)
    #print(playerList)
    #final_loot_assign()
    #final_cover_assign()
    #print_Rooms()
    #engineer_1 = Engineer(20,12,10,10)
    #print_map()
    #move(player1)
    #position(engineer_1)
    #randomPos(player1)
    #cover(engineer_1)
    #print(engineer_1.cover)
    #run_Turn(engineer_1)
    #position(engineer_1)
    #move(player1)
    #loot(engineer_1)
    #print(engineer_1.inventory)
    #position(engineer_1)
    #print(map[engineer_1.i][engineer_1.j])
    #attack(engineer_1, 10)
    #check_Attack(engineer_1)
    #print(engineer_1.will_attack)
    #isDead(engineer_1)
    #print(engineer_1.isdead)
    #print(engineer_1.health)
    #attack(engineer_1, 60)
    #print(engineer_1.health)
    #isDead(engineer_1)
    #print(engineer_1.isdead)
    #check_Move(engineer_1)
    #print(engineer_1.will_move)
    #move(engineer_1)
    #move(engineer_1)
    #print(engineer_1.strength)
    #print(engineer_1.AC)
    #print(engineer_1.WS)
    #print(engineer_1.BS)
    #print(roll(6))
    #map_step_one()
    #map_step_two()
    #print_map()
    #print(num_of_blanks)
    #map_step_three()
    #map_step_four(num_of_blanks, num_of_tiles)
    #print_map()
    #for i in range(0,11): print(map[i].count(0)) #counts the free spaces
    # print(rooms)
    # print(rooms_actual)
    #print_Rooms()
    #move(engineer_1)
    #move(engineer_1)
    #move(engineer_1)
    #position(engineer_1)
    #check_Loot(engineer_1)
    #loot(engineer_1)
    #check_Loot(engineer_1)
    #loot(engineer_1)
    #print(engineer_1.inventory)




main()


# NEW BAND NAME THE FEET OF CHILDREN

### TO DO LIST ###
# Make a Terminal and present a list of options for the user
# Function to make players and auto roll them // Finished \\
# Check room function that is different from loot and shows interactable (Tables to overturn lol and cover of room)
# Placement of characters //Finished\\
    # Make sure they're not directly on an island //Finished\\
    # Place them in a room that is actually a room //Finished\\
# Creation of loot pools into a seperate dictionaries and compile that into a list // FINISHED (roomList) \\
    # Key bind position to hold loot // FINISHED \\
    # Transfer of loot to character  // FINISHED \\
    # Figure out which loot will belong in which room //eh\\
        # rarity of loot? -> make more instances of commoner items in the loot list
# Crafting (Will be done with dictionaries and will start with very few recipies)
# Make Cover that has to be interacted with for it to be cover. (Tables)
# Turn Phases
    # this would be like action reaction and stuff like that and the player would have choose which one to do.
# Server/ hosting / multiplayer
    # Turn mechanism
# Movement into non-zero places // Finished \\
# Actually attacking
    # Attacking buffs
# Figure out logs
    # Figure out where to store the logs // done (turns out its useless :p \\
# Start up sequence
    # How many players and adding them to a list
# Stats of pretty much everything
# Make a reset so players can only loot once per turn!!!!!!!!!!!!!!!!!!!
# !!!!
# !!!!
# BONDING AS ROOMMATES :)