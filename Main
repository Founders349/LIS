#!/usr/bin/env python
import random
import json
import logging
def roll(Nsides):
    roll=random.randint(1,Nsides)
    return(roll)

                                            ### Start Map Generation ###
# gets the map size based of user input
def get_map_size():
    num_of_tiles = 0
    while num_of_tiles == 0:
        mapsize = input('Enter S/M/L: ')
        if mapsize == 'S':
            num_of_tiles = random.randrange(25, 35)
            print("The Map is", num_of_tiles, "Tiles")
            return num_of_tiles
        elif mapsize == 'M':
            num_of_tiles = random.randrange(40, 60)
            print("The Map is", num_of_tiles, "Tiles")
            return num_of_tiles
        elif mapsize == 'L':
            num_of_tiles = random.randrange(80, 100)
            print("The Map is", num_of_tiles, "Tiles")
            return num_of_tiles

# stores the map size so we can make the map
num_of_tiles = get_map_size()
# Creates the map size returning the amount of rows and columns
def map_step_one():
    if num_of_tiles < 36:
        rows, cols = (7,7)
        return rows, cols
    elif 36 < num_of_tiles < 61:
        rows, cols = (9,9)
        return rows, cols
    else:
        rows, cols = (11,11)
        return rows, cols
# Stores map template
rows, cols = map_step_one()

# creates map as a list
def map_step_two():
    #arr = [[0 for i in range(cols)] for j in range(rows)]
    #return arr
    map = [[0 for x in range(rows)] for x in range(cols)]
    return map
# stores the map
map = map_step_two()
# prints the map in a useable way
def print_map():
    for i in range(len(map)):
        for j in range(len(map[i])):
            print(map[i][j], end=" ")
        print()

# creates blank tiles
def map_step_three():
    if num_of_tiles < 36:
        num_of_blanks = 49 - num_of_tiles
        return num_of_blanks
    elif 36 < num_of_tiles < 61:
        num_of_blanks = 81 - num_of_tiles
        return num_of_blanks
    else:
        num_of_blanks = 121 - num_of_tiles
        return num_of_blanks

# stores blank tiles
num_of_blanks = map_step_three()

# Creates the rooms types               ***This will probably be taken out to favor the JSON files***
# class Room:
#    num = 0
 #   max = 0
  #  pass

#class Medbay(Room):
 #   room_type = "Medbay"
  #  room_ID = 1

#class Armory(Room):
 #   room_type = "Armory"
  #  room_ID = 2

#class Storage(Room):
 #   room_type = "Storage"
  #  room_ID = 3

#class Security(Room):
 #   room_type = "Security"
  #  room_ID = 4

#class Airlock(Room):
 #   room_type = "Airlock"
  #  room_ID = 5

#class Lab(Room):
 #   room_type = "Lab"
  #  room_ID = 6
pass

# Function to check if the room can take more of that room type (Doesnt do anything but im afraid to take it out)
def check_avail(x):
    if map.count(x) < 10: return True
    else: return False

# Replaces blank rooms with random room types
def map_step_four(num_of_blanks, num_of_tiles):
    i, j = (0, 0)
    blanks = num_of_blanks
    tiles = num_of_tiles
    while ((blanks + tiles - 1) > 0):
        room = random.randrange(0,7)
        if room == 0 and (blanks > 0):
            map[i][j] = room
            blanks -= 1
            if j < rows-1:
                j += 1
            else:
                j = 0
                i += 1
        elif check_avail(room) == True:
            tiles -= 1
            if j < rows-1:
                j += 1
                map[i][j] = room
            else:
                i, j = (i+1, 0)
                map[i][j] = room

# Start up function that makes the map
def make_map():
    map_step_one()
    map_step_two()
    map_step_three()
    map_step_four(num_of_blanks, num_of_tiles)

                                               ### Start Loot Generation ###
def randomLootGenerator(randomLootList):
  return randomLootList[random.randrange(len(randomLootList))]

rooms=[]
rooms_actual = []
def assign_loottest(): #This is jus a basic test set up this will not be final
    roomfiles = ["./Room1.json","./Room2.json", "./Room3.json", "./Room4.json", "./Room5.json", "./Room6.json"]

    for filename in roomfiles:
        with open(filename) as f:
            roomjson = json.load(f)
        assert isinstance(roomjson, dict)
        rooms.append(roomjson)
    print("Number of Room Types: " + str(len(rooms)))
    for x in rooms:
        print("Type: " + x.get("Type"))
        roommod = []
        roommod.append(x.get("Type"))
        for m in range((x.get("MaxLoot"))):
            y = randomLootGenerator(x.get("Loot"))
            roommod.append(y)
            print("Loot: " + y)
        rooms_actual.append(roommod)
    return rooms, rooms_actual

def assign_loot(roomNum, i, j):
    roomfiles = ["./Room1.json", "./Room2.json", "./Room3.json", "./Room4.json", "./Room5.json", "./Room6.json"]
    with open(roomfiles[roomNum-1]) as f:
        roomjson = json.load(f)
    assert isinstance(roomjson, dict)
    roomdict_small = {}


    pass
# Runs through the map and assigns random loot based off of the room type calling assign_loot() to assign the loot
def final_loot_assign(): # Super unfinished
    for i in map[i]:
        for j in map[i][j]:
            if map[i][j] == 0:
                pass
            elif map[i][j] == 1:
                roomNUM = 1
                assign_loot(roomNUM, i, j)
                return


                                                ### Start PC's ###
# defines Playable Characters
class Human:

    health = 50
    isdead = False
    will_move = "N"
    will_search = "N"
    will_interact = "N"
    will_attack = "N"
    # initializes character with character stats
    def __init__(self, strength, AC, WS, BS, i, j):
        self.strength = strength
        self.AC = AC
        self.WS = WS
        self.BS = BS
        self.i = i
        self.j = j

# subclasses of Human
class Engineer(Human):
    equiptment = "maintenance tool"
    skill = "Override"
class Doctor(Human):
    equiptment = "Meds"
    equiptment_amount = 2
    skill = "PHD", "Blood Timer"
class Veteran(Human):
    equiptment = "Deagle"
    skill = "Pilot"
class Technician(Human):
    pass
class Chemist(Human):
    pass
class Astronaut(Human):
    pass
class Delegate(Human):
    pass


# basic attack setup
# checks for attack
def check_Attack(name):
    case = 0
    while case == 0:
        will_attack = input("Will you attack? Y/N ")
        if will_attack == "Y":
            name.will_attack = "Y"
            break
        elif will_attack == "N":
            name.will_attack = "N"
            break
        else: name.will_attack = "N"
    return name.will_attack

def attack(name, damage):
    name.health = (name.health - damage)
    return name.health

                                           ### Start turn based functions ###
# Checks if the player is dead
def isDead(name):
    if name.health <=0:
        name.isdead = True
    else:
        name.isdead = False
# Asks player to see if they will move
def check_Move(name):
    case = 0
    while case == 0:
        will_move = input("Will you move? Y/N ")
        if will_move == "Y":
            name.will_move = "Y"
            break
        elif will_move == "N":
            name.will_move = "N"
            break
        else:
            name.will_move = "N"
    return name.will_move
# Asks player if they will search the room
def check_Search(name):
    will_search = input("Will you search your current room? Y/N ")
    if will_search == "Y":
        name.will_search = "Y"
    elif will_search == "N":
        name.will_search = "N"
    else:
        name.will_search = "N"
    return name.will_search
# Asks the player if they want to interact with the room
def check_Interact(name):
    will_interact = input("Will you interact with the current room? Y/N ")
    if will_interact == "Y":
        name.will_interact = "Y"
    elif will_interact == "N":
        name.will_interact = "N"
    else:
        name.will_interact = "N"
    return name.will_interact
# Moves the player
def move(name):
    if (name.will_move == 'Y'):
        move = input("Which Direction?  ")
        if move == "U":
            name.i -= 1
        elif move == "D":
            name.i += 1
        elif move == "L":
            name.j -= 1
        elif move == "R":
            name.j += 1
        else: return

# def run_Turn(name):
    # pass

    # will_attack = input("Will you attack? Y/N")
    # if (will_attack == "Y"):
    #    print("Okay")
# Checks the position of a player
def position(name):
    print(name.i, name.j)
# tests all my code
def main():
    #print(num_of_tiles)
    engineer_1 = Engineer(20,12,10,10, 0, 0)
    attack(engineer_1, 10)
    check_Attack(engineer_1)
    print(engineer_1.will_attack)
    isDead(engineer_1)
    print(engineer_1.isdead)
    print(engineer_1.health)
    attack(engineer_1, 60)
    #print(engineer_1.health)
    isDead(engineer_1)
    print(engineer_1.isdead)
    check_Move(engineer_1)
    print(engineer_1.will_move)
    move(engineer_1)
    move(engineer_1)
    position(engineer_1)
    #print(engineer_1.strength)
    #print(engineer_1.AC)
    #print(engineer_1.WS)
    #print(engineer_1.BS)
    #print(roll(6))
    #map_step_one()
    #map_step_two()
    #print_map()
    #print(num_of_blanks)
    #map_step_three()
    #map_step_four(num_of_blanks, num_of_tiles)
    make_map()
    print_map()
    #for i in range(0,11): print(map[i].count(0)) #counts the free spaces
    assign_loottest()
    print(rooms)
    print(rooms_actual)


main()


# NEW BAND NAME THE FEET OF CHILDREN

### TO DO LIST ###
# Placement of characters
    # Make sure they're not directly on an island
    # Place them in a room that is actually a room
# Creation of loot pools into a somewhat large dictionary
    # Key bind position to hold loot
    # Transfer of loot to characters
    # Figure out which loot will belong in which room
        # rarity of loot?
# Crafting (Will be done with dictionaries and will start with very few recipies)
# Server/ hosting / multiplayer
    # Turn mechanism
# Movement into non-zero places
# Actually attacking
# Figure out logs
    # Figure out where to store the logs
# Start up sequence
# Stats of pretty much everything
# BONDING AS ROOMMATES :)